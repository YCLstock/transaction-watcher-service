# Go Ethereum Transaction Watcher Service

[![Go Version](https://img.shields.io/badge/Go-1.25+-blue.svg)](https://go.dev/) [![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)

一個使用 **Go 語言**開發的、準生產級的區塊鏈交易監聽服務。它基於 **WebSocket** 實現了對以太坊事件的**即時發布/訂閱 (Pub/Sub)**，並利用 **Goroutine** 和 **Channel** 處理高併發數據流。本專案旨在模擬中心化交易所 (CEX) 監聽用戶充值的核心業務邏輯，並具備**自動錯誤重試**和**斷線重連**的健壯性。

## 🏛️ 架構 (Architecture)

本服務採用了**生產者-消費者模型**，將「接收事件」與「處理事件」解耦，實現高併發處理：

`[ Eth Node ] --(WebSocket)--> [ 主 Goroutine (接收) ] --(Channel)--> [ Worker Goroutines (處理) ] --(Log)--> [ Console ]`

## ✨ 主要功能 (Key Features)

*   **⚡ 即時事件訂閱:** 基於 `go-ethereum` 函式庫，使用 **WebSocket** 的 `SubscribeNewHead` 方法，實現對新區塊的低延遲、即時訂閱。
*   **🚀 高併發處理:** 採用**工人池 (Worker Pool)** 模式，利用 **Goroutine** 並行處理新區塊的數據獲取與交易解析，確保不會阻塞事件流。
*   **🛡️ 高可靠性設計:** 內建了基於 `for` 迴圈和 `time.Sleep` 的**自動斷線重連**機制，能夠應對網路波動和 RPC 節點短暫故障。
*   **🎯 精準目標過濾:** 能夠在區塊的所有交易中，高效篩選出發送到**指定監控地址**的交易。
*   **📝 專業結構化日誌:** 引入 **Logrus** 函式庫，所有輸出均為結構化的 JSON 格式日誌，並包含 `Info`, `Warn`, `Error` 等不同級別，便於日誌的收集與分析。
*   **⚙️ 環境變數配置:** 使用 `.env` 檔案管理敏感配置（如 API Key），無需修改原始碼。

## 🚀 快速開始 (Getting Started)

1.  **複製本專案**
    ```bash
    git clone https://github.com/your-username/go-ethereum-watcher.git
    cd go-ethereum-watcher
    ```
2.  **安裝依賴**
    ```bash
    go mod tidy
    ```
3.  **配置環境變數**
    *   將 `.env.example` 檔案複製為 `.env`。
    *   打開 `.env` 檔案，將 `ALCHEMY_WSS_URL` 的值替換為您自己的 Ethereum WebSocket RPC URL。
    ```env
    # .env
    ALCHEMY_WSS_URL="wss://eth-sepolia.g.alchemy.com/v2/YOUR_API_KEY"
    ```
4.  **運行服務**
    ```bash
    go run main.go
    ```

## 🔍 核心代碼解析

### `main()` 函式

`main` 函式是服務的入口點和「守護者」。它使用一個無限 `for` 迴圈來確保 `startWatching` 函式在因任何錯誤退出後，都能在短暫延遲後自動重啟，實現了服務的健壯性。

```go
func main() {
    godotenv.Load() // 載入 .env
    for {
        startWatching() // 啟動核心監聽邏輯
        logrus.Warn("監聽器已停止，將在 15 秒後嘗試重啟...")
        time.Sleep(15 * time.Second) // 發生錯誤，等待後重試
    }
}
```

### `startWatching()` 函式 - 生產者與消費者

`startWatching` 函式是我們的核心業務邏輯，它實現了**生產者-消費者模型**：

1.  **建立連線與訂閱 (Setup):**
    *   使用 `ethclient.Dial()` 建立 WebSocket 連線。
    *   使用 `client.SubscribeNewHead()` 訂閱新區塊事件，獲得一個接收新區塊頭的 Channel (`headers`)。

2.  **建立工人池 (Consumers):**
    *   創建一個帶緩衝的 Channel `processQueue`，作為任務隊列。
    *   啟動固定數量的 Goroutine（工人），它們都阻塞式地等待從 `processQueue` 獲取任務。
    *   每個工人的工作是：獲取區塊頭 -> 呼叫 `BlockByHash` 獲取完整區塊 -> 遍歷交易並過濾。

    ```go
    processQueue := make(chan *types.Header, 100)

    for i := 1; i <= numWorkers; i++ {
        go func(workerID int) {
            for header := range processQueue {
                // ... 處理區塊的耗時操作 ...
            }
        }(i)
    }
    ```

3.  **主事件迴圈 (Producer):**
    *   `for-select` 迴圈現在變得非常輕量。它的唯一職責是監聽兩個 Channel：
        *   `<-sub.Err()`: 如果訂閱出錯，關閉 `processQueue` 以通知所有工人停止工作，然後 `return`，觸發 `main` 函式的重連機制。
        *   `<-headers`: 當新區塊到達時，**立即**將其發送到 `processQueue` 任務隊列，然後繼續等待下一個事件，**完全不會被區塊處理的過程阻塞**。

    ```go
    for {
        select {
        case err := <-sub.Err():
            close(processQueue) // 關閉隊列，讓工人退出
            return
        case header := <-headers:
            processQueue <- header // 將任務發送給工人
        }
    }
    ```